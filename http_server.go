package go_rest_api_server

import (
	"context"
	"crypto/rand"
	"crypto/rsa"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/pem"
	"fmt"
	"log/slog"
	"math/big"
	"net"
	"net/http"
	"os"
	"sync"
	"time"

	"github.com/dan-sherwin/go-rest-api-server/middlewares"
	"github.com/gin-gonic/gin"
)

// httpApp is the instance of the Gin Engine used for HTTP routing and handling.
//
// httpServer represents the HTTP server that will serve requests over the network.
//
// ListeningAddress is the address and port the server listens on for incoming HTTP connections.
var (
	httpApp               *gin.Engine
	httpServer            *http.Server
	httpsServer           *http.Server
	ListeningAddress      = "0.0.0.0:5555"
	HTTPSListeningAddress = "0.0.0.0:5556"
	disablePing           = false

	// track self-signed TLS files we generated so we can clean them up on shutdown
	autoGeneratedTLSFiles bool
	generatedCertPath     string
	generatedKeyPath      string
	once                  sync.Once
)

// init configures the HTTP server with necessary middlewares including CORS, request ID generation, logging, and no-cache headers, and initializes the Gin engine with recovery and trusted proxy settings.
func init() {
	slog.Debug("initializing http server")
	gin.SetMode(gin.ReleaseMode)
	httpApp = gin.New()
	httpApp.Use(gin.Recovery())
	_ = httpApp.SetTrustedProxies(nil)
	httpApp.Use(gin.Recovery(), middlewares.CORSMiddleware(), middlewares.RequestLogger(), middlewares.NoCache())
}

// StartHttpServer initializes and starts an HTTP server at the specified listening address.
// It sets up routes, logs server start information, and handles any errors during server startup.
// Runs the server in a separate goroutine to allow non-blocking operation.
func StartHttpServer() {
	slog.Info(fmt.Sprintf("starting service on http://%s", ListeningAddress))
	once.Do(setupRoutes)
	httpServer = &http.Server{Addr: ListeningAddress, Handler: httpApp.Handler()}
	go func() {
		slog.Info("listening and serving HTTP on " + ListeningAddress)
		if err := httpServer.ListenAndServe(); err != nil {
			if err.Error() != "http: Server closed" {
				slog.Error("error occurred while setting up the server. " + err.Error())
				os.Exit(1)
			}
		}
	}()
}

// StartHttpsServer initializes and starts an HTTPS server with TLS using the provided certificate and key files.
// It listens on the globally defined HTTPSListeningAddress and handles HTTP routes through the configured httpApp router.
// The server runs asynchronously and logs relevant startup and error messages.
func StartHttpsServer(certFile, keyFile string, autoSelfSigned bool) {
	slog.Info(fmt.Sprintf("starting tls http service on http://%s", HTTPSListeningAddress))
	once.Do(setupRoutes)

	var err error
	certPath := certFile
	keyPath := keyFile
	// reset tracking by default
	autoGeneratedTLSFiles = false
	generatedCertPath = ""
	generatedKeyPath = ""

	if certPath == "" || keyPath == "" || !fileExists(certPath) || !fileExists(keyPath) {
		if autoSelfSigned {
			certPath, keyPath, err = generateSelfSignedCertFiles(certPath, keyPath)
			if err != nil {
				slog.Error("failed to generate self-signed certificate: " + err.Error())
				os.Exit(1)
			}
			// remember these so we can clean them up later
			autoGeneratedTLSFiles = true
			generatedCertPath = certPath
			generatedKeyPath = keyPath
		} else {
			slog.Error("TLS cert or key path not provided or not found, and autoSelfSigned is false")
			os.Exit(1)
		}
	}

	httpsServer = &http.Server{Addr: HTTPSListeningAddress, Handler: httpApp.Handler()}
	go func() {
		slog.Info("listening and serving HTTPS on " + HTTPSListeningAddress)
		if err := httpsServer.ListenAndServeTLS(certPath, keyPath); err != nil {
			if err.Error() != "http: Server closed" {
				slog.Error("error occurred while setting up the HTTPS server. " + err.Error())
				os.Exit(1)
			}
		}
	}()
}

// DisablePing sets the internal `disablePing` variable to true, effectively disabling the ping functionality.
func DisablePing() {
	disablePing = true
}

// RegisterRouters registers multiple router configurations to the HTTP application engine. It accepts a variadic number of functions, each receiving the *gin.Engine instance for adding routes and middleware.
func RegisterRouters(registrars ...func(r *gin.Engine)) {
	for _, r := range registrars {
		r(httpApp)
	}
}

// ShutdownHttpServer gracefully shuts down the HTTP server, if it is running, using a background context. It returns an error if the shutdown process encounters any issues or if the server cannot be properly terminated.
func ShutdownHttpServer() error {
	if httpServer == nil {
		return nil
	}
	return httpServer.Shutdown(context.Background())
}

// setupRoutes defines HTTP routes and their corresponding handlers for the application.
func setupRoutes() {
	httpApp.NoRoute(func(c *gin.Context) {
		c.JSON(http.StatusNotFound, gin.H{
			"message": "Not Found",
		})
	})
	if !disablePing {
		httpApp.GET("/ping", func(c *gin.Context) {
			c.JSON(200, gin.H{
				"message": "pong",
			})
		})
	}
}

// ClientIP retrieves the client IP address from the request context. It checks the "X-Forwarded-For" header first and returns its value if present; otherwise, it falls back to using c.ClientIP().
func ClientIP(c *gin.Context) string {
	buf := c.GetHeader("X-Forwarded-For")
	if buf != "" {
		return buf
	}
	return c.ClientIP()
}

// ShutdownHttpsServer gracefully shuts down the HTTPS server.
func ShutdownHttpsServer() error {
	if httpsServer == nil {
		// even if server wasn't started, allow cleanup if files were generated
		cleanupGeneratedTLSFiles()
		return nil
	}
	err := httpsServer.Shutdown(context.Background())
	// attempt cleanup regardless of shutdown success
	cleanupGeneratedTLSFiles()
	return err
}

// fileExists reports whether the named file exists.
func fileExists(path string) bool {
	if path == "" {
		return false
	}
	if _, err := os.Stat(path); err == nil {
		return true
	}
	return false
}

// cleanupGeneratedTLSFiles removes any self-signed cert/key files generated by this package.
// It is safe to call multiple times. Errors are logged at debug level and otherwise ignored.
func cleanupGeneratedTLSFiles() {
	if !autoGeneratedTLSFiles {
		return
	}
	if generatedCertPath != "" {
		if err := os.Remove(generatedCertPath); err != nil {
			slog.Debug("failed to remove generated TLS cert file", slog.String("path", generatedCertPath), slog.String("error", err.Error()))
		} else {
			slog.Debug("removed generated TLS cert file", slog.String("path", generatedCertPath))
		}
	}
	if generatedKeyPath != "" {
		if err := os.Remove(generatedKeyPath); err != nil {
			slog.Debug("failed to remove generated TLS key file", slog.String("path", generatedKeyPath), slog.String("error", err.Error()))
		} else {
			slog.Debug("removed generated TLS key file", slog.String("path", generatedKeyPath))
		}
	}
	// clear state
	autoGeneratedTLSFiles = false
	generatedCertPath = ""
	generatedKeyPath = ""
}

// CleanupGeneratedTLSFiles removes any self-signed cert/key files generated by StartHttpsServer.
// Intended for applications to call (e.g., via defer) if they want to ensure cleanup even without calling ShutdownHttpsServer.
func CleanupGeneratedTLSFiles() {
	cleanupGeneratedTLSFiles()
}

// generateSelfSignedCertFiles generates a self-signed certificate and key, writes them to files, and returns their paths.
// If certOut or keyOut are empty, temporary files will be created in the OS temp directory.
func generateSelfSignedCertFiles(certOut, keyOut string) (string, string, error) {
	// Ensure output paths
	if certOut == "" {
		f, err := os.CreateTemp("", "rest_api_server_cert_*.pem")
		if err != nil {
			return "", "", err
		}
		_ = f.Close()
		certOut = f.Name()
	}
	if keyOut == "" {
		f, err := os.CreateTemp("", "rest_api_server_key_*.pem")
		if err != nil {
			return "", "", err
		}
		_ = f.Close()
		keyOut = f.Name()
	}

	// Generate a private key
	priv, err := rsa.GenerateKey(rand.Reader, 2048)
	if err != nil {
		return "", "", err
	}

	// Create certificate template
	serialNumberLimit := new(big.Int).Lsh(big.NewInt(1), 128)
	serialNumber, err := rand.Int(rand.Reader, serialNumberLimit)
	if err != nil {
		return "", "", err
	}
	template := x509.Certificate{
		SerialNumber: serialNumber,
		Subject: pkix.Name{
			CommonName:   "rest-api-server",
			Organization: []string{"Spacelink"},
		},
		NotBefore: time.Now().Add(-time.Hour),
		NotAfter:  time.Now().Add(365 * 24 * time.Hour),

		KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature | x509.KeyUsageCertSign,
		ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
		BasicConstraintsValid: true,
		IsCA:                  true,
	}

	// Add common hostnames and IPs
	hosts := []string{"localhost"}
	for _, h := range hosts {
		template.DNSNames = append(template.DNSNames, h)
	}
	for _, ipStr := range []string{"127.0.0.1", "::1"} {
		if ip := net.ParseIP(ipStr); ip != nil {
			template.IPAddresses = append(template.IPAddresses, ip)
		}
	}

	// Create the certificate
	derBytes, err := x509.CreateCertificate(rand.Reader, &template, &template, &priv.PublicKey, priv)
	if err != nil {
		return "", "", err
	}

	// Write cert file
	if err := os.WriteFile(certOut, pem.EncodeToMemory(&pem.Block{Type: "CERTIFICATE", Bytes: derBytes}), 0644); err != nil {
		return "", "", err
	}

	// Write key file
	keyPem := pem.EncodeToMemory(&pem.Block{Type: "RSA PRIVATE KEY", Bytes: x509.MarshalPKCS1PrivateKey(priv)})
	if err := os.WriteFile(keyOut, keyPem, 0600); err != nil {
		return "", "", err
	}

	return certOut, keyOut, nil
}
