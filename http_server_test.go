package restapi

import (
	"context"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"sync"
	"testing"
	"time"

	"github.com/dan-sherwin/go-rest-api-server/middlewares"
	"github.com/gin-gonic/gin"
)

// test helpers

// resetState attempts to restore package globals to a clean state between tests.
func resetState(t *testing.T) {
	t.Helper()
	// Shut down any running servers (ignore errors in cleanup path)
	_ = ShutdownHttpServer()
	_ = ShutdownHttpsServer()

	// Clear server handles and config
	httpServer = nil
	httpsServer = nil
	httpServers = nil
	httpsServers = nil

	ListeningAddresses = nil
	HTTPSListeningAddresses = nil

	// Reset defaults for single address (tests will override)
	ListeningAddress = "127.0.0.1:5555"
	HTTPSListeningAddress = "127.0.0.1:5556"

	// Enable ping by default
	disablePing = false

	// Reset generated TLS tracking
	autoGeneratedTLSFiles = false
	generatedCertPath = ""
	generatedKeyPath = ""

	// Reset routes: create fresh gin engine mirroring init()
	gin.SetMode(gin.ReleaseMode)
	httpApp = gin.New()
	httpApp.Use(gin.Recovery())
	_ = httpApp.SetTrustedProxies(nil)
	httpApp.Use(gin.Recovery(), middlewares.CORSMiddleware(), middlewares.RequestLogger(), middlewares.NoCache())

	// Reset once so setupRoutes can run again
	once = sync.Once{}
}

// waitForHTTP polls an HTTP URL until it returns 200 or timeout elapses.
func waitForHTTP(url string, timeout time.Duration) error {
	deadline := time.Now().Add(timeout)
	client := &http.Client{Timeout: 500 * time.Millisecond}
	for time.Now().Before(deadline) {
		resp, err := client.Get(url)
		if err == nil {
			io.Copy(io.Discard, resp.Body)
			resp.Body.Close()
			if resp.StatusCode == 200 {
				return nil
			}
		}
		time.Sleep(100 * time.Millisecond)
	}
	return fmt.Errorf("HTTP not ready at %s within %s", url, timeout)
}

// waitForHTTPS is like waitForHTTP but with optional InsecureSkipVerify for self-signed.
func waitForHTTPS(url string, timeout time.Duration) error {
	deadline := time.Now().Add(timeout)
	tr := &http.Transport{TLSClientConfig: &tls.Config{InsecureSkipVerify: true}}
	client := &http.Client{Timeout: 500 * time.Millisecond, Transport: tr}
	for time.Now().Before(deadline) {
		resp, err := client.Get(url)
		if err == nil {
			io.Copy(io.Discard, resp.Body)
			resp.Body.Close()
			if resp.StatusCode == 200 {
				return nil
			}
		}
		time.Sleep(100 * time.Millisecond)
	}
	return fmt.Errorf("HTTPS not ready at %s within %s", url, timeout)
}

func TestHTTPServerSingleAddressPing(t *testing.T) {
	resetState(t)

	ListeningAddress = "127.0.0.1:18080"

	StartHttpServer()
	defer func() {
		if err := ShutdownHttpServer(); err != nil {
			t.Fatalf("shutdown error: %v", err)
		}
	}()

	if err := waitForHTTP("http://"+ListeningAddress+"/ping", 10*time.Second); err != nil {
		t.Fatalf("server not ready: %v", err)
	}

	resp, err := http.Get("http://" + ListeningAddress + "/ping")
	if err != nil {
		t.Fatalf("GET /ping failed: %v", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode != 200 {
		t.Fatalf("expected 200, got %d", resp.StatusCode)
	}
	var body map[string]any
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		t.Fatalf("invalid json: %v", err)
	}
	if body["message"] != "pong" {
		t.Fatalf("unexpected body: %v", body)
	}
}

func TestHTTPServerMultipleAddresses(t *testing.T) {
	resetState(t)

	ListeningAddresses = []string{"127.0.0.1:18081", "127.0.0.1:18082"}

	StartHttpServer()
	defer func() {
		if err := ShutdownHttpServer(); err != nil {
			t.Fatalf("shutdown error: %v", err)
		}
	}()

	for _, addr := range ListeningAddresses {
		if err := waitForHTTP("http://"+addr+"/ping", 10*time.Second); err != nil {
			t.Fatalf("server not ready at %s: %v", addr, err)
		}
		resp, err := http.Get("http://" + addr + "/ping")
		if err != nil {
			t.Fatalf("GET /ping on %s failed: %v", addr, err)
		}
		resp.Body.Close()
		if resp.StatusCode != 200 {
			t.Fatalf("expected 200 from %s, got %d", addr, resp.StatusCode)
		}
	}
}

func TestHTTPSServerSelfSignedAndCleanup(t *testing.T) {
	resetState(t)

	HTTPSListeningAddresses = []string{"127.0.0.1:18443"}

	StartHttpsServer("", "", true)
	// Record paths for later verification
	certPath := generatedCertPath
	keyPath := generatedKeyPath
	if certPath == "" || keyPath == "" {
		t.Fatalf("expected generated cert/key paths, got cert=%q key=%q", certPath, keyPath)
	}

	defer func() {
		if err := ShutdownHttpsServer(); err != nil {
			t.Fatalf("shutdown error: %v", err)
		}
		// After shutdown, files should be removed and variables cleared
		if _, err := os.Stat(certPath); !os.IsNotExist(err) {
			t.Fatalf("expected cert file removed: %s (err=%v)", certPath, err)
		}
		if _, err := os.Stat(keyPath); !os.IsNotExist(err) {
			t.Fatalf("expected key file removed: %s (err=%v)", keyPath, err)
		}
		if generatedCertPath != "" || generatedKeyPath != "" || autoGeneratedTLSFiles {
			t.Fatalf("expected generated paths cleared after shutdown")
		}
	}()

	// Wait for readiness and verify /ping
	url := "https://" + HTTPSListeningAddresses[0] + "/ping"
	if err := waitForHTTPS(url, 15*time.Second); err != nil {
		t.Fatalf("HTTPS server not ready: %v", err)
	}

	tr := &http.Transport{TLSClientConfig: &tls.Config{InsecureSkipVerify: true}}
	client := &http.Client{Transport: tr, Timeout: 5 * time.Second}
	resp, err := client.Get(url)
	if err != nil {
		t.Fatalf("GET /ping over TLS failed: %v", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode != 200 {
		t.Fatalf("expected 200, got %d", resp.StatusCode)
	}
}

func TestClientIPHeaderTakesPrecedence(t *testing.T) {
	resetState(t)

	// Register a temporary route that echoes the resolved client IP
	RegisterRouters(func(r *gin.Engine) {
		r.GET("/ip", func(c *gin.Context) {
			ip := ClientIP(c)
			c.JSON(200, gin.H{"ip": ip})
		})
	})

	ListeningAddress = "127.0.0.1:18090"
	StartHttpServer()
	defer func() {
		if err := ShutdownHttpServer(); err != nil {
			t.Fatalf("shutdown error: %v", err)
		}
	}()

	if err := waitForHTTP("http://"+ListeningAddress+"/ip", 10*time.Second); err != nil {
		t.Fatalf("server not ready: %v", err)
	}

	req, _ := http.NewRequestWithContext(context.Background(), http.MethodGet, "http://"+ListeningAddress+"/ip", nil)
	req.Header.Set("X-Forwarded-For", "203.0.113.9")
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		t.Fatalf("GET /ip failed: %v", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode != 200 {
		t.Fatalf("expected 200, got %d", resp.StatusCode)
	}
	var body map[string]string
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		t.Fatalf("invalid json: %v", err)
	}
	if body["ip"] != "203.0.113.9" {
		t.Fatalf("expected ip 203.0.113.9, got %q", body["ip"])
	}
}
